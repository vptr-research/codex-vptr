# Day 3 - 2026-02-09

## What I Did Today
C01 ex02-05 complete (pointer basics working!)

## Day Type
A (building code)

## What I Learned

### Pointers - The Main Concept

**The Big Idea:**
- A pointer is like an arrow pointing to a box (variable)
- `&` means "give me the address" (where the box is)
- `*` means "go to that address and get/change what's inside"

**Key Understanding:**
```c
int x = 5;        // x is a box with 5 inside
int *ptr = &x;    // ptr is an arrow pointing to x's box
*ptr = 10;        // follow the arrow, change the box to 10
// now x = 10
```

### Pointer vs Regular Variable

**Regular variable:**
```c
int num = 42;     // just a value
```

**Pointer variable:**
```c
int *ptr;         // an arrow (not initialized - dangerous!)
int x = 5;
ptr = &x;         // now ptr points to x
```

### The Test File Pattern

**Wrong way (crashes):**
```c
int *c;           // pointer to random memory
*c = 42;          // writing to random place → CRASH
```

**Right way:**
```c
int c;            // normal variable
funcao(&c);       // pass its address to function
```

### When to Use & (Address-of)

**Rule:** If function wants a pointer, give it an address.

```c
void ft_swap(int *a, int *b);    // function wants pointers

int main(void)
{
    int x = 5;
    int y = 10;
    ft_swap(&x, &y);             // give addresses with &
}
```

### When NOT to Use &

If you already have a pointer:
```c
int x = 5;
int *ptr = &x;        // ptr is already a pointer
funcao(ptr);          // pass it directly (no & needed)
```

### When to Initialize Variables

**Need to initialize (will read before writing):**
```c
int x;              // not initialized
int y = x + 5;      // ❌ ERROR: reading x first
```

**Don't need to initialize (only writing):**
```c
int result;         // not initialized - OK
funcao(&result);    // function will write to it
// now result has a value
```

### Bugs I Fixed

**Bug 1: ft_swap - changing pointer instead of value**
```c
// WRONG:
void ft_swap(int *a, int *b)
{
    int swap = *a;
    a = b;          // ❌ now a points to b's location
    *b = swap;      // lost connection to original a!
}

// CORRECT:
void ft_swap(int *a, int *b)
{
    int swap = *a;
    *a = *b;        // ✅ change the VALUE at a
    *b = swap;      // ✅ change the VALUE at b
}
```

**What I learned:** Never change where the pointer points (`a = b`). Only change the value it points to (`*a = *b`).

**Bug 2: Creating uninitialized pointers in tests**
```c
// WRONG:
int *num1;          // random address
*num1 = 42;         // ❌ writing to random memory

// CORRECT:
int num1 = 42;      // normal variable
funcao(&num1);      // pass its address
```

**Bug 3: ft_ultimate_div_mod - division instead of modulo**
```c
*b = temp / *b;     // ❌ division again
*b = temp % *b;     // ✅ modulo (resto)
```

**Bug 4: ft_putstr - writing pointer address instead of character**
```c
write(1, &str, 1);      // ❌ writes address
write(1, &str[i], 1);   // ✅ writes character
```

### The Golden Rules I Learned

1. **Function wants pointer → pass address with &**
2. **Never change the pointer itself (`a = b`) → only change values (`*a = *b`)**
3. **Test files use normal variables, not pointers**
4. **Uninitialized pointer = crash waiting to happen**
5. **When writing with write(), make sure you're writing the actual data, not its address**

## Proof of Work
- ex02: ft_swap tested and working (swapped 42 and 32)
- ex03: ft_div_mod tested (10÷3 = 3 remainder 1)
- ex04: ft_ultimate_div_mod tested (same result)
- ex05: ft_putstr tested ("Hello" printed correctly)

## Exercises Done Today
- [x] C01 ex02: ft_swap (swap two integers using pointers)
- [x] C01 ex03: ft_div_mod (division and modulo using output pointers)
- [x] C01 ex04: ft_ultimate_div_mod (same but modifying input pointers)
- [x] C01 ex05: ft_putstr (print string by following pointer)

## Tomorrow
- Continue C01: ex06 (ft_strlen) onwards
- Goal: Finish C01 if possible

## Things I Noticed
- **Pointer concept clicked**: The "arrow pointing to box" mental model works
- **Pattern recognition**: All test files follow same structure (normal vars + &)
- **Debugging getting faster**: Found bugs quicker by tracing through code
- **Asked for no hints**: Wanted to struggle and learn properly
- **English correction**: Asked for simpler language in daily notes

## Notes
Pointers aren't scary anymore. The key was understanding:
- Variables = boxes with values
- Pointers = arrows to boxes
- & = "where is this box?"
- * = "what's in the box this arrow points to?"

All exercises tested and working. Ready for ex06 tomorrow.
