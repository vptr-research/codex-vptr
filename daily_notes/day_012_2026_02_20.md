# Day 12 - 2026-02-20

## Artifact
C02 ex12: ft_print_memory (needs review and consolidation)

## Day Type
A (construction)

## What I Learned

### Technical Skills
- Bitwise operations: `>>` (shift right), `&` (bitwise AND), `|` (OR), `^` (XOR)
- Extracting nibbles from 64-bit addresses using shift + mask
- Multi-column formatting with precise spacing
- Pointer arithmetic: `(char *)addr + offset` to advance through memory
- `void*` requires cast to `char*` before arithmetic operations
- Loop offset tracking to process data in chunks (16 bytes per line)
- Padding calculations for alignment when data < expected size

### Bugs Found & Fixed
1. **Endereço não atualizava entre linhas**: `num` calculado fora do loop externo
   - **Cause**: `num = (unsigned long)addr` só executava uma vez
   - **Fix**: Movido para dentro do loop: `num = (unsigned long)((char *)addr + offset)`
   - **Lesson**: Variables that change per iteration must be recalculated inside the loop

2. **shift não resetava**: na segunda linha, `shift` já estava negativo
   - **Cause**: `shift = 60` estava fora do loop externo
   - **Fix**: Movido para dentro do while externo, antes do loop de endereço
   - **Lesson**: State variables need reset for each iteration

3. **Loops internos processavam todos os bytes**: comparavam `i < size` total
   - **Cause**: Não consideravam offset da linha atual
   - **Fix**: Mudado para `(offset + i) < size`
   - **Lesson**: When processing chunks, indices must account for current offset

4. **Confusão entre endereço e conteúdo**: pensava que iria imprimir o endereço de novo
   - **Cause**: Não distinguia coluna 1 (endereço) vs coluna 2 (conteúdo na memória)
   - **Fix**: Entendi que `ptr[i]` **lê** bytes da memória, não reutiliza o endereço
   - **Lesson**: Address (where) vs content (what) are fundamentally different

### Important Insights
- **Bitwise operations work on individual bits**: `>>` shifts bits right, `&` masks specific bits
- `0xf` (binary `1111`) is used to isolate last 4 bits (1 nibble)
- A byte (8 bits) = 2 nibbles = 2 hex digits
- Hex is just a **representation** — internally everything is binary
- `printf("%x")` does manually what we implemented: number → hex string conversion
- This exercise is direct preparation for ft_printf's `%x` and `%p` format specifiers
- Understanding memory as raw bytes (not typed data) is essential for low-level work

### Conceptual Gaps (Needs Review)
- Bitwise operations are understood at surface level but not deeply internalized
- Pointer arithmetic with void* and casts needs more practice
- The relationship between shifts, nibbles, and hex digits requires consolidation
- Multi-level loop coordination (outer loop for lines, inner loops for columns) felt complex

## Evidence
- Compiles with `-Wall -Wextra -Werror`
- Test output with size=40:
  ```
  000000016f57afb8: 2a00 0000 0000 0000 20 576f 0100 0000  *....... .Wo....
  000000016f57afc8: 54 54@� 0100 0000 0000 0000 0000 0000  T.T.............
  000000016f57afd8: 0100 0000 0000 0000                      ........
  ```
- Three columns working: address, hex content, printable content
- Multi-line output functioning (processes in 16-byte chunks)
- Padding implemented for alignment when size < 16

## Exercises Completed
- [x] ex12: ft_print_memory (functional but needs deeper understanding)

## Tomorrow's Plan
- Review ft_print_memory concepts independently
- Start C03 ex00 (ft_strcmp)
- Continue with C03 string comparison functions

## Notes
- **IMPORTANT**: This exercise required significant external guidance. The concepts (bitwise ops, multi-level loops, address vs content) are not fully consolidated. Plan to:
  1. Re-read the code with fresh eyes in 2-3 days
  2. Watch additional tutorials on bitwise operations
  3. Revisit when doing ft_printf to reinforce the concepts
- ft_print_memory is the hardest exercise in the entire Piscina — it's normal to struggle
- The mental model of "memory as raw bytes" vs "typed data" is still forming
- This exercise bridges to ft_printf (`%x`, `%p`) and deeper systems programming
- Need to refactor into helper functions for norminette compliance (25-line limit)
