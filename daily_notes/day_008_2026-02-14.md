# Day 8 - 2026-02-14

## Artifact
C02 ex10: ft_strlcpy

## Day Type
A (construction)

## What I Learned

### Technical Skills
- `strlcpy` always returns the full length of `src`, regardless of `size`
- This allows the caller to detect truncation: if return > size-1, truncation occurred
- When `size == 0`, does not touch `dest` — only returns `strlen(src)`
- Copies at most `size - 1` chars and null-terminates at `dest[size-1]`
- Condition `i < size - 1 && i < len` prevents reading memory beyond `src`
- Base 16: hex digits extracted with `>> 4` (high nibble) and `& 0xf` (low nibble)
- Lookup string `"0123456789abcdef"` to convert numeric digit to hex char
- `unsigned char` for byte values (0-255), not `int`

### Bugs Found & Fixed
1. **Reading beyond src**: original condition `i < size - 1` copied garbage memory when `src` was shorter than `size`
   - **Cause**: loop didn't check end of `src`
   - **Fix**: added `&& i < len`
   - **Lesson**: always bound the loop on both sides — destination size AND source size

2. **Contaminated test**: `size == 0` case appeared wrong but was leftover data from previous test in the same buffer
   - **Cause**: reused same buffer between tests
   - **Fix**: declared separate variables for each test case
   - **Lesson**: tests need isolated buffers to be reliable

### Important Insights
- Difference between `strlcpy` and `strncpy`: `strlcpy` is safer because it always null-terminates and returns the real length of `src`
- Sentinel value (`dest[0] = 'X'`) to verify function truly didn't touch the buffer when `size == 0`

## Evidence
- Compiles with `-Wall -Wextra -Werror`
- 4 cases tested: normal size, size < src, size == 0, empty src
- Verified with sentinel that size==0 does not touch dest

## Exercises Completed
- [x] ex10: ft_strlcpy

## Tomorrow's Plan
- C02 ex11: ft_putstr_non_printable
- C02 ex12: ft_print_memory
- Start C03 if time permits

## Notes
- Learned base 16 today for the first time — hex digit extraction with bitwise ops is cleaner than division/modulo
