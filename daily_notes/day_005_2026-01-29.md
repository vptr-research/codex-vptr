# Day 5 | Phase 1 | Type A | 2026-01-29

## Target Artifact
ft_isalpha implementation with tests and manual compilation

## Day Type Justification
Type A (Construction) - Building specified functionality (character check function).
No discovery target - straightforward implementation of known spec.

## Study
- Read `man 3 isalpha`
- Learned: Function accepts unsigned char (0-255) or EOF (-1)
- Learned: Returns non-zero for alphabetic, 0 otherwise
- Key insight: EOF (-1) must return 0, not undefined behavior

## Implementation
**File:** `projects/libft/src/ft_isalpha.c`

Logic:
- Check if c in range [65-90] (A-Z) OR [97-122] (a-z)
- Return 1 if true, 0 if false
- Uses decimal values (not char literals) to practice ASCII values
- Handles EOF (-1) correctly by design (fails both range checks)

**Decision:** Used decimal values instead of char literals to reinforce 
understanding of ASCII table after initial confusion with octal values.

## Testing
**File:** `projects/libft/tests/test_isalpha.c`

Test cases:
- Alphabetic: 'A', 'B', 'c', 'd', 'E', 'f' → all returned 1
- Non-alphabetic: -1 (EOF), '0' → both returned 0
- Validation: Compared output with libc `isalpha()`
- Result: 8/8 tests passed

Test approach: Hybrid of exit codes + comparison with reference implementation

## Debug Evidence
Compilation: `gcc -Wall -Wextra -Werror -fsanitize=address,undefined`
Sanitizer output: Clean (no warnings from ASan or UBSan)
Exit code: 0 (all tests passed)

No LLDB/GDB session needed - function is trivial (<20 lines, no pointers, 
no allocation) per CODEX justification rules.

## Failure / Negative Result
Type A day - no discovery target.

Initial implementation error: Used octal values (101, 132, 141, 172) 
thinking they were decimal. Also used OR (||) when AND (&&) was needed.
Root cause: Confusion between number bases (octal/decimal) and typo in 
logical operator - not a conceptual misunderstanding of boolean logic.
Corrected after systematic review of man page and operator verification.

## Failure Model Extracted
Type A day - no failure model required.

However, documented learning:
- Confusion between octal/decimal/char literal representations
- This is a knowledge gap, not a security failure model

## Post-Mortem
None required - no bug in final implementation.

## Open Questions
None - ft_isalpha is complete.

## Tomorrow
**Artifact:** ft_isdigit implementation + tests + manual compilation
**Day type:** Type A (construction)
